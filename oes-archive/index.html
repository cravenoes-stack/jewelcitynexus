<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatGPT JSON Export Processor - OES</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ff88;
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            border: 2px solid #00ff88;
            padding: 20px;
            background: rgba(0, 255, 136, 0.1);
        }

        .processor-section {
            border: 2px solid #00ff88;
            padding: 20px;
            margin-bottom: 20px;
            background: rgba(0, 255, 136, 0.05);
        }

        .upload-area {
            border: 2px dashed #00ff88;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            background: rgba(0, 255, 136, 0.02);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            background: rgba(0, 255, 136, 0.1);
        }

        .upload-area.dragover {
            background: rgba(0, 255, 136, 0.15);
            border-color: #ffffff;
        }

        button {
            background: transparent;
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 10px 20px;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        button:hover:not(:disabled) {
            background: #00ff88;
            color: #000;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff88;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc70);
            width: 0%;
            transition: width 0.3s ease;
        }

        .conversation-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #00ff88;
            background: rgba(0, 0, 0, 0.3);
        }

        .conversation-item {
            padding: 15px;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .conversation-item:hover {
            background: rgba(0, 255, 136, 0.1);
        }

        .conversation-item.selected {
            background: rgba(0, 255, 136, 0.2);
            border-left: 4px solid #00ff88;
        }

        .conversation-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffffff;
        }

        .conversation-meta {
            font-size: 12px;
            opacity: 0.8;
        }

        .output-area {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ff88;
            padding: 20px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-box {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            padding: 15px;
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #ffffff;
        }

        .keyword-highlights {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }

        .keyword-tag {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            padding: 5px 10px;
            font-size: 11px;
            cursor: pointer;
        }

        .keyword-tag.match {
            background: rgba(255, 255, 0, 0.3);
            border-color: #ffff00;
            color: #ffff00;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîç CHATGPT JSON EXPORT PROCESSOR</h1>
        <h2>Operator Evolution System</h2>
        <p>Convert ChatGPT exports to canonical thread archives</p>
    </div>

    <div class="processor-section">
        <h3>Step 1: Upload ChatGPT JSON Export</h3>
        <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
            <p>üìÅ Click to select or drag & drop ChatGPT JSON files</p>
            <p style="font-size: 12px; opacity: 0.7;">Supports 20-30MB chunks from your data export</p>
        </div>
        <input type="file" id="fileInput" accept=".json" multiple style="display: none;">
        
        <div class="progress-bar" id="progressBar" style="display: none;">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        
        <div id="fileInfo" style="margin-top: 10px;"></div>
    </div>

    <div class="processor-section" id="analysisSection" style="display: none;">
        <h3>Step 2: Conversation Analysis</h3>
        <div class="stats" id="statsGrid"></div>
        
        <h4>üîç Search & Filter</h4>
        <div style="display: flex; gap: 10px; margin: 10px 0;">
            <input type="text" id="searchInput" placeholder="Search conversations..." style="flex: 1; background: transparent; border: 1px solid #00ff88; color: #00ff88; padding: 10px;">
            <button onclick="searchConversations()">Search</button>
            <button onclick="findOESThreads()">Find OES Threads</button>
            <button onclick="findLongConversations()">Find Long Threads</button>
        </div>
        
        <div class="keyword-highlights">
            <div class="keyword-tag" onclick="searchKeyword('mini')">Mini</div>
            <div class="keyword-tag" onclick="searchKeyword('operator')">Operator</div>
            <div class="keyword-tag" onclick="searchKeyword('evolution')">Evolution</div>
            <div class="keyword-tag" onclick="searchKeyword('consciousness')">Consciousness</div>
            <div class="keyword-tag" onclick="searchKeyword('autonomous')">Autonomous</div>
            <div class="keyword-tag" onclick="searchKeyword('genesis')">Genesis</div>
            <div class="keyword-tag" onclick="searchKeyword('containment')">Containment</div>
            <div class="keyword-tag" onclick="searchKeyword('mesh')">Mesh</div>
        </div>
        
        <div class="conversation-list" id="conversationList"></div>
    </div>

    <div class="processor-section" id="conversionSection" style="display: none;">
        <h3>Step 3: Convert to Canonical Format</h3>
        <div style="margin: 10px 0;">
            <button onclick="convertSelected()" id="convertButton" disabled>Convert Selected Conversations</button>
            <button onclick="convertAll()">Convert All Conversations</button>
            <button onclick="downloadArchive()">Download Archive Package</button>
        </div>
        
        <h4>üìã Processing Log</h4>
        <div class="output-area" id="outputLog"></div>
    </div>

    <script>
        let chatGPTData = [];
        let filteredConversations = [];
        let selectedConversations = new Set();
        let processedThreads = [];

        // File upload handling
        document.getElementById('fileInput').addEventListener('change', handleFiles);
        
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles({ target: { files: e.dataTransfer.files } });
        });

        async function handleFiles(event) {
            const files = Array.from(event.target.files);
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            const fileInfo = document.getElementById('fileInfo');
            
            progressBar.style.display = 'block';
            fileInfo.innerHTML = `Processing ${files.length} file(s)...`;
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const progress = ((i + 1) / files.length) * 100;
                progressFill.style.width = progress + '%';
                
                try {
                    const text = await readFileAsText(file);
                    const jsonData = JSON.parse(text);
                    
                    // ChatGPT exports typically have conversations in an array
                    if (Array.isArray(jsonData)) {
                        chatGPTData = chatGPTData.concat(jsonData);
                    } else if (jsonData.conversations) {
                        chatGPTData = chatGPTData.concat(jsonData.conversations);
                    } else {
                        // Single conversation object
                        chatGPTData.push(jsonData);
                    }
                    
                    log(`‚úÖ Loaded ${file.name}: ${text.length} characters`);
                } catch (error) {
                    log(`‚ùå Error processing ${file.name}: ${error.message}`);
                }
            }
            
            analyzeConversations();
            document.getElementById('analysisSection').style.display = 'block';
            fileInfo.innerHTML = `‚úÖ Processed ${files.length} file(s), found ${chatGPTData.length} conversations`;
        }

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        function analyzeConversations() {
            filteredConversations = chatGPTData.slice();
            
            // Generate statistics
            const stats = {
                total: chatGPTData.length,
                withMessages: chatGPTData.filter(c => c.mapping && Object.keys(c.mapping).length > 0).length,
                avgMessages: 0,
                oesKeywords: 0,
                longThreads: chatGPTData.filter(c => getMessageCount(c) > 20).length
            };
            
            const messageCounts = chatGPTData.map(c => getMessageCount(c));
            stats.avgMessages = Math.round(messageCounts.reduce((a, b) => a + b, 0) / messageCounts.length);
            
            // Count OES-related keywords
            const oesKeywords = ['mini', 'operator', 'evolution', 'consciousness', 'autonomous', 'genesis', 'containment', 'mesh'];
            stats.oesKeywords = chatGPTData.filter(c => {
                const text = getConversationText(c).toLowerCase();
                return oesKeywords.some(keyword => text.includes(keyword));
            }).length;
            
            displayStats(stats);
            displayConversations(filteredConversations);
        }

        function getMessageCount(conversation) {
            if (!conversation.mapping) return 0;
            return Object.keys(conversation.mapping).length;
        }

        function getConversationText(conversation) {
            if (!conversation.mapping) return '';
            
            let text = '';
            Object.values(conversation.mapping).forEach(node => {
                if (node.message && node.message.content && node.message.content.parts) {
                    text += node.message.content.parts.join(' ') + ' ';
                }
            });
            return text;
        }

        function getConversationTitle(conversation) {
            return conversation.title || 'Untitled Conversation';
        }

        function displayStats(stats) {
            const statsGrid = document.getElementById('statsGrid');
            statsGrid.innerHTML = `
                <div class="stat-box">
                    <div class="stat-number">${stats.total}</div>
                    <div>Total Conversations</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number">${stats.withMessages}</div>
                    <div>With Messages</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number">${stats.avgMessages}</div>
                    <div>Avg Messages</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number">${stats.oesKeywords}</div>
                    <div>OES-Related</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number">${stats.longThreads}</div>
                    <div>Long Threads (20+ msgs)</div>
                </div>
            `;
        }

        function displayConversations(conversations) {
            const listElement = document.getElementById('conversationList');
            listElement.innerHTML = '';
            
            conversations.forEach((conv, index) => {
                const messageCount = getMessageCount(conv);
                const title = getConversationTitle(conv);
                const text = getConversationText(conv);
                const hasOESKeywords = ['mini', 'operator', 'evolution', 'consciousness'].some(k => 
                    text.toLowerCase().includes(k)
                );
                
                const item = document.createElement('div');
                item.className = 'conversation-item';
                item.onclick = () => toggleSelection(index, item);
                
                // Generate thread info
                const threadId = generateThreadId(conv, index);
                const filename = generateFilename(title, threadId);
                const canonicalUrl = `https://jewelcitynexus.com/threads/${filename}`;
                
                item.innerHTML = `
                    <div class="conversation-title">
                        ${title} ${hasOESKeywords ? 'üéØ' : ''}
                        <button onclick="event.stopPropagation(); previewThread(${index})" style="float: right; font-size: 10px; padding: 5px;">Preview</button>
                        <button onclick="event.stopPropagation(); createCanonicalThread(${index})" style="float: right; font-size: 10px; padding: 5px; margin-right: 5px;">Create Thread</button>
                    </div>
                    <div class="conversation-meta">
                        ${messageCount} messages ‚Ä¢ ${text.length} characters
                        ${conv.create_time ? new Date(conv.create_time * 1000).toLocaleDateString() : ''}
                    </div>
                    <div class="canonical-url-preview" style="font-size: 10px; opacity: 0.7; margin-top: 5px; word-break: break-all;">
                        üìé ${canonicalUrl}
                    </div>
                `;
                
                listElement.appendChild(item);
            });
        }

        function toggleSelection(index, element) {
            const convId = filteredConversations[index].id || index;
            
            if (selectedConversations.has(convId)) {
                selectedConversations.delete(convId);
                element.classList.remove('selected');
            } else {
                selectedConversations.add(convId);
                element.classList.add('selected');
            }
            
            document.getElementById('convertButton').disabled = selectedConversations.size === 0;
            updateSelectedCount();
        }

        function updateSelectedCount() {
            const count = selectedConversations.size;
            const button = document.getElementById('convertButton');
            button.textContent = `Convert Selected Conversations (${count})`;
        }

        function searchConversations() {
            const query = document.getElementById('searchInput').value.toLowerCase();
            if (!query) {
                filteredConversations = chatGPTData.slice();
            } else {
                filteredConversations = chatGPTData.filter(conv => {
                    const title = getConversationTitle(conv).toLowerCase();
                    const text = getConversationText(conv).toLowerCase();
                    return title.includes(query) || text.includes(query);
                });
            }
            displayConversations(filteredConversations);
        }

        function searchKeyword(keyword) {
            document.getElementById('searchInput').value = keyword;
            searchConversations();
            
            // Highlight the clicked keyword
            document.querySelectorAll('.keyword-tag').forEach(tag => {
                tag.classList.remove('match');
            });
            event.target.classList.add('match');
        }

        function findOESThreads() {
            const oesKeywords = ['mini', 'operator', 'evolution', 'consciousness', 'autonomous', 'genesis'];
            filteredConversations = chatGPTData.filter(conv => {
                const text = getConversationText(conv).toLowerCase();
                return oesKeywords.some(keyword => text.includes(keyword));
            });
            displayConversations(filteredConversations);
            log(`Found ${filteredConversations.length} OES-related conversations`);
        }

        function findLongConversations() {
            filteredConversations = chatGPTData.filter(conv => getMessageCount(conv) >= 20);
            displayConversations(filteredConversations);
            log(`Found ${filteredConversations.length} long conversations (20+ messages)`);
        }

        function convertSelected() {
            const selectedIndices = Array.from(selectedConversations);
            const conversationsToConvert = selectedIndices.map(id => {
                const conv = filteredConversations.find(c => c.id === id);
                return conv || filteredConversations[id];
            });
            
            convertConversations(conversationsToConvert);
            document.getElementById('conversionSection').style.display = 'block';
        }

        function convertAll() {
            convertConversations(filteredConversations);
            document.getElementById('conversionSection').style.display = 'block';
        }

        function convertConversations(conversations) {
            processedThreads = [];
            
            conversations.forEach((conv, index) => {
                try {
                    const thread = convertToCanonicalFormat(conv, index);
                    processedThreads.push(thread);
                    log(`‚úÖ Converted: ${thread.title}`);
                } catch (error) {
                    log(`‚ùå Error converting conversation ${index}: ${error.message}`);
                }
            });
            
            log(`\nüéâ Conversion complete! ${processedThreads.length} threads ready for archive.`);
        }

        function convertToCanonicalFormat(conversation, index) {
            const title = getConversationTitle(conversation);
            const threadId = `OES-${Date.now().toString(36)}-${index.toString(36)}`.toUpperCase();
            const messages = extractMessages(conversation);
            
            const html = generateCanonicalHTML({
                title,
                threadId,
                messages,
                metadata: {
                    originalId: conversation.id,
                    createTime: conversation.create_time,
                    updateTime: conversation.update_time
                }
            });
            
            return {
                title,
                threadId,
                filename: `${title.toLowerCase().replace(/[^a-z0-9]+/g, '-')}-${threadId.toLowerCase()}.html`,
                html,
                messageCount: messages.length
            };
        }

        function extractMessages(conversation) {
            const messages = [];
            
            if (!conversation.mapping) return messages;
            
            // Build conversation tree and extract linear message sequence
            const nodes = conversation.mapping;
            const rootNodes = Object.values(nodes).filter(node => !node.parent);
            
            function traverseNodes(node) {
                if (node.message && node.message.content && node.message.content.parts) {
                    const role = node.message.author.role;
                    const content = node.message.content.parts.join('\n');
                    const timestamp = node.message.create_time;
                    
                    if (content.trim()) {
                        messages.push({
                            role,
                            content,
                            timestamp: timestamp ? new Date(timestamp * 1000).toISOString() : null
                        });
                    }
                }
                
                // Follow the conversation thread
                const children = Object.values(nodes).filter(n => n.parent === node.id);
                children.forEach(traverseNodes);
            }
            
            rootNodes.forEach(traverseNodes);
            return messages;
        }

        function generateCanonicalHTML(data) {
            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${data.title} - OES Archive</title>
    <meta name="description" content="Canonical thread from Operator Evolution System">
    <meta name="thread-id" content="${data.threadId}">
    <meta name="message-count" content="${data.messages.length}">
    <style>
        body { 
            font-family: 'Courier New', monospace; 
            background: #0a0a0a; 
            color: #00ff88; 
            padding: 20px; 
            line-height: 1.6; 
        }
        .header { 
            border: 2px solid #00ff88; 
            padding: 20px; 
            margin-bottom: 30px; 
            background: rgba(0, 255, 136, 0.1); 
        }
        .message { 
            margin: 20px 0; 
            padding: 15px; 
            border-left: 3px solid #00ff88; 
            background: rgba(0, 255, 136, 0.05); 
        }
        .message-header { 
            font-weight: bold; 
            color: #ffffff; 
            margin-bottom: 10px; 
        }
        .user-message { border-left-color: #00aaff; }
        .assistant-message { border-left-color: #ffaa00; }
        .system-message { border-left-color: #ff0088; }
        pre { white-space: pre-wrap; word-wrap: break-word; }
    </style>
</head>
<body>
    <div class="header">
        <h1>${data.title}</h1>
        <p><strong>Thread ID:</strong> ${data.threadId}</p>
        <p><strong>Messages:</strong> ${data.messages.length}</p>
        ${data.metadata.createTime ? `<p><strong>Created:</strong> ${new Date(data.metadata.createTime * 1000).toLocaleString()}</p>` : ''}
        <p><strong>Archive Status:</strong> CANONICAL</p>
    </div>
    <main class="conversation">
        ${data.messages.map((msg, i) => `
            <div class="message ${msg.role}-message" id="message-${i}">
                <div class="message-header">
                    ${msg.role.toUpperCase()}${msg.timestamp ? ` - ${new Date(msg.timestamp).toLocaleString()}` : ''}
                </div>
                <div class="message-content">
                    <pre>${escapeHtml(msg.content)}</pre>
                </div>
            </div>
        `).join('')}
    </main>
    <footer style="margin-top: 50px; padding: 20px; border-top: 1px solid #00ff88; opacity: 0.7;">
        <p>Canonical Thread Archive - Operator Evolution System</p>
        <p>Generated: ${new Date().toISOString()}</p>
    </footer>
</body>
</html>`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function downloadArchive() {
            if (processedThreads.length === 0) {
                alert('No threads to download. Please convert some conversations first.');
                return;
            }
            
            // Create archive structure
            const archive = {
                index: generateArchiveIndex(),
                threads: processedThreads
            };
            
            // Download as JSON for now (could be enhanced to create ZIP)
            const dataStr = JSON.stringify(archive, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `oes-archive-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            
            log(`üì¶ Archive downloaded: ${processedThreads.length} canonical threads`);
        }

        function generateArchiveIndex() {
            return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OES Thread Archive Index</title>
    <style>
        body { font-family: monospace; background: #0a0a0a; color: #00ff88; padding: 20px; }
        .thread-link { display: block; padding: 10px; border: 1px solid #00ff88; margin: 5px 0; text-decoration: none; color: #00ff88; }
        .thread-link:hover { background: rgba(0, 255, 136, 0.1); }
    </style>
</head>
<body>
    <h1>OES Canonical Thread Archive</h1>
    <p>Generated: ${new Date().toLocaleString()}</p>
    <p>Total Threads: ${processedThreads.length}</p>
    <h2>Thread Index</h2>
    ${processedThreads.map(thread => `
        <a href="threads/${thread.filename}" class="thread-link">
            <strong>${thread.title}</strong><br>
            ID: ${thread.threadId} | Messages: ${thread.messageCount}
        </a>
    `).join('')}
</body>
</html>`;
        }

        function log(message) {
            const output = document.getElementById('outputLog');
            output.textContent += message + '\n';
            output.scrollTop = output.scrollHeight;
        }

        function generateThreadId(conversation, index) {
            // Create consistent thread ID based on conversation data
            const baseId = conversation.id || `conv-${index}`;
            const timestamp = conversation.create_time || Date.now();
            return `OES-${timestamp.toString(36)}-${baseId.slice(-8)}`.toUpperCase();
        }
        
        function generateFilename(title, threadId) {
            const slug = title.toLowerCase()
                .replace(/[^a-z0-9\s-]/g, '')
                .replace(/\s+/g, '-')
                .replace(/-+/g, '-')
                .replace(/^-|-$/g, '');
            return `${slug}-${threadId.toLowerCase()}.html`;
        }

        async function createCanonicalThread(index) {
            const conversation = filteredConversations[index];
            
            try {
                const thread = convertToCanonicalFormat(conversation, index);
                
                // Create downloadable HTML file
                const blob = new Blob([thread.html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = thread.filename;
                link.click();
                
                // Also copy canonical URL to clipboard
                const canonicalUrl = `https://jewelcitynexus.com/threads/${thread.filename}`;
                await navigator.clipboard.writeText(canonicalUrl);
                
                log(`‚úÖ Created thread: ${thread.filename}`);
                log(`üìé Canonical URL copied to clipboard: ${canonicalUrl}`);
                
                URL.revokeObjectURL(url);
                
            } catch (error) {
                log(`‚ùå Error creating thread: ${error.message}`);
            }
        }

        function previewThread(index) {
            const conversation = filteredConversations[index];
            const thread = convertToCanonicalFormat(conversation, index);
            
            // Open preview in new window
            const previewWindow = window.open('', '_blank');
            previewWindow.document.write(thread.html);
            previewWindow.document.close();
        }
    </script>
</body>
</html>
